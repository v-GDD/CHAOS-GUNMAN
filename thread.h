//================================================================================================================
//
// DirectXのマルチスレッド用ヘッダファイル [thread.h]
// Author : TENMA
//
//================================================================================================================
#ifndef _THREAD_H_
#define _THREAD_H_

//**********************************************************************************
//*** インクルードファイル ***
//**********************************************************************************
#include <process.h>
#include "main.h"

//**********************************************************************************
//*** マクロ定義 ***
//**********************************************************************************
#define DEFAULT_PROC			&DefThreadProc		// デフォルトスレッドプロシージャ
#define CREATE_LOOPID(loopname)	void loopname(void)	// ループ関数作成マクロ

//**********************************************************************************
//*** 競合保護構造体定義 ***
//**********************************************************************************
typedef struct MultiData
{
public:
	unsigned int nCountEnterSection;

private:
	// クリティカルセクションによる競合保護
	CRITICAL_SECTION cs;
	bool bSafe;

public:
	// コンストラクタ
	MultiData() : bSafe(true), nCountEnterSection(0) { InitializeCriticalSection(&cs); }

	// デストラクタ
	~MultiData() { bSafe = false; nCountEnterSection = 0; DeleteCriticalSection(&cs); }

	// クリティカルセクション獲得開始
	void LockMultiData(void)
	{
		if (bSafe)
		{
			EnterCriticalSection(&cs);
			nCountEnterSection++;
		}
	}

	// クリティカルセクション獲得終了
	void UnlockMultiData(void)
	{
		if (bSafe)
		{
			LeaveCriticalSection(&cs);
			nCountEnterSection--;
		}
	}

} MultiData;

//**********************************************************************************
//*** スレッド情報構造体定義 ***
//**********************************************************************************
typedef struct ThreadData
{
	unsigned int ThreadId;		// スレッドID
	int nFPS;					// スレッドループ間隔
	int nLoopCount;				// スレッドループ回数(-1は無限ループ)

	void (*LoopID)(void);		// ループ時実行関数
	bool bExit;					// スレッドループ終了変数

	int nSleepTime;				// 一時停止時間
	bool bPlay;					// 再生中か
} ThreadData;

//**********************************************************************************
//*** マルチスレッド構造体定義 ***
//**********************************************************************************
typedef struct Thread
{
	/*****************************************************************************************************************
	|																												 |
	|	注意！																										 |
	|																												 |
	|		Thread構造体の関数は、DEFAULT_PROCを使用することを前提として作られています。							 |
	|		スレッドプロシージャに別のものを使用する場合は、DEFAULT_PROCを参考に作成してください。					 |
	|																												 |
	|																												 |
	****************************************************************************************************************/

private:
	HANDLE hThread;				// スレッドハンドル
	ThreadData* ptData;			// スレッド情報
	bool bSafe;					// 参照可能判定
	bool bDest;					// デストラクタによる自動解放

public:
	// コンストラクタ
	Thread() : hThread(NULL), ptData(NULL), bSafe(false), bDest(false) {}

	// デストラクタ
	~Thread()
	{
		if (hThread != NULL && bDest == true)
		{ // スレッドハンドルが存在する場合、解放
			ptData->bExit = true;

			WaitForSingleObject(hThread, INFINITE);
			CloseHandle(hThread);
			hThread = NULL;
			ptData = NULL;
			bSafe = false;
		}
	}

	/****************************************************************************************************************
	 スレッド生成
	 説明 : スレッドの作成を行います。

	 引数 :
	 tData		: ThreadDataへのポインタ 
				  (※WinMain以外で使用する場合グローバル変数で用意しないとスレッドの正常終了が出来なくなります。)
	  
	 ThreadProc : スレッドで使用するプロシージャへのポインタ
				  (基本はDEFAULT_PROCで問題ないです。自作したい場合は返り値がunsigned int WINAPIで作成してください。)
	 
	 bOnDest	: デストラクタ時のスレッド及びハンドルの自動解放の有無
				  (trueにすると、変数のデストラクタ時自動で作成したスレッド及びハンドルが解放されます。
				  WinMain等で使用する場合は、trueにしておくとリリースが不要になります。)
			　	  (※falseにする場合、必ず明示的に解放(Release)を行ってください。)

	 lpThread	: スレッド変数のポインタを格納する変数へのダブルポインタ
				  (NULLでも大丈夫です。)

	 返り値		: スレッド作成の成功判定。

	 追記		: 一つのThread変数につき一つまでしかスレッドは作成できません。
				  同じ変数で再度作成したい場合、一度解放を行ってください。
				  作成した場合、失敗します。
	****************************************************************************************************************/
	_Check_return_ bool CreateThread(_In_ ThreadData* tData, _In_ _beginthreadex_proc_type ThreadProc, _In_ bool bOnDest, _Outptr_opt_ Thread **lpThread);

	/****************************************************************************************************************
	 スレッド破棄
	 説明		: スレッドの解放を行います。

	 引数		: 無し。

	 返り値		: 無し。

	 追記		: Release時、Thread変数がNULLかのチェックを行ってください。
				  スレッドハンドルが有効かは関数内でチェックするため、取り敢えずReleaseしておいてもいいです。
	****************************************************************************************************************/
	void Release();

	/****************************************************************************************************************
	 ### 警告 : スレッド停止の最終手段です。極力使用は控えてください。 ###

	 スレッドの強制破棄
	 説明		: 強制的に現在のスレッドの停止を行います。即座にスレッドが停止します。成功時、ハンドルの開放も行います。

	 引数 : 
	 dwExitCode : スレッドの終了コード。GetExitCodeThreadにて取得できます。
				  (※259は定義済みの為使用しないでください。)

	 返り値		: スレッドの終了の成功判定。

	 追記		: この関数を使用すると、現在スレッド内で行っている処理を中断しスレッドを終了します。
				  スレッド内で確保したメモリ領域は解放されません。その為、メモリリークの危険性があります。
				  スレッドに異常が起き、スレッドの終了が不可能になった場合のみ使用することを強くお勧めします。
	****************************************************************************************************************/
	bool ForceRelease(DWORD dwExitCode = 1);

	/****************************************************************************************************************
	 スレッドハンドル取得
	 説明			: スレッドのハンドルを取得します。

	 引数 : 
	 pThreadHandle	: 取得したスレッドハンドルの格納先へのポインタ (失敗時はNULLを返します。)

	 返り値			: スレッドハンドル取得の成功判定。

	 追記			: スレッドハンドルがNULL,格納先へのポインタがNULLの場合は失敗します。
	****************************************************************************************************************/
	bool GetThreadHandle(HANDLE* pThreadHandle);

	/****************************************************************************************************************
	 スレッドの確認
	 説明		: スレッドが生成済みかどうか確認します。

	 引数		: 無し。

	 返り値		: スレッドの有無。

	 追記		: スレッドの作成時、念の為この関数を通しておくことをお勧めします。
				  CreateThread内でも確認していますが、通しておいた方が身の為です。
	****************************************************************************************************************/
	bool IsThread(void);

	/****************************************************************************************************************
	 スレッドの停止
	 説明		: 現在ループ中のスレッドを一時停止します。

	 引数		: 無し。

	 返り値		: 無し。

	 追記		: 既に停止中のスレッドに使用しても問題ありません。
				  スレッド休止中だと、休止時間はリセットされスレッドが停止します。
	****************************************************************************************************************/
	void StopThread(void);

	/****************************************************************************************************************
	 スレッドの休止
	 説明		: 現在ループ中のスレッドを一定時間停止します。

	 引数 : 
	 nSleepTime : ミリ秒単位での停止時間(PC時間で計算します。)

	 返り値		: 無し。

	 追記		: スレッド休止中に再度実行すると、再度休止を始めます。また、スレッド停止中に実行すると停止が解除され、
				  休止が優先されます。
	****************************************************************************************************************/
	void SleepThread(int nSleepTime);

	/****************************************************************************************************************
	 スレッドの再生
	 説明		: 一時停止中、もしくはスリープ中のスレッドループを再度開始します。

	 引数		: 無し。

	 返り値		: 無し。

	 追記		: 既にループ開始しているスレッドに使用しても問題ありません。
				  休止中のスレッドに使用すると、即座にスレッドが再生します。
	****************************************************************************************************************/
	void PlayThread(void);
} Thread;

typedef Thread* LPTHREAD;

//**********************************************************************************
//*** プロトタイプ宣言 ***
//**********************************************************************************
unsigned WINAPI DefThreadProc(LPVOID lpParam);

#endif
